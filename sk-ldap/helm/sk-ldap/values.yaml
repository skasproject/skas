
nameOverride:
fullNameOverride:

# ---------------------------------------------------------------------
# Following will allow renaming of resources. You can safely leave undefined and let default values
#
# Will default to {{ include "sk-crd.fullname" . }}-cert
certificateSecretName:
# Will default to {{ include "sk-crd.fullname" . }}
certificateName:
# Will default to {{ include "sk-crd.fullname" . }}
deploymentName:
# Will default to {{ include "sk-crd.fullname" . }}-config
configName:
# Will default to {{ include "sk-crd.fullname" . }}
serviceName:
# Will default to {{ include "sk-crd.fullname" . }}
ingressName:

# ---------------------------------------------------------------------

replicaCount: 2

image:
  pullSecrets: []
  repository: ghcr.io/skasproject/skas
  # -- Overrides the image tag whose default is the chart appVersion.
  tag:
  pullPolicy: Always

log:
  mode: json
  level: info


# -- Additional arguments to be added to the executable's args list
additionalArgs: {}

# -- Annotations to be added to the pod
podAnnotations: {}

# -- Annotations to be added to all other resources
commonAnnotations: {}

server:
  port: 7011
  ssl: true

# -- Security Context for the whole pod
podSecurityContext:
  runAsNonRoot: true
  seccompProfile:
    type: RuntimeDefault
  # fsGroup: 2000

extraEnv: {}
# Add here environment variable definitions. May be used to inject secret value in config file
#  - name: MY_SECRET
#    valueFrom:
#      secretKeyRef:
#        name: k8s-secret-name
#        key: theSecret

resources: {}
# If you want to specify resources, uncomment the following
# lines, adjust them as necessary, and remove the curly braces after 'resources:'.
#
#  limits:
#    cpu: 100m
#    memory: 200Mi
#  requests:
#    cpu: 100m
#    memory: 100Mi

# -- Nodeselector for the operator to be installed
nodeSelector: {}

# -- Tolerations for the operator to be installed
tolerations: []

# -- Affinity for the operator to be installed
affinity: {}

ingressClass: nginx # Don't change, as only 'nginx' is supported for now.

# ---------------------------------------------------------------------------------------
# The following are context dependant. Should be defined in a context related values file

# The To access the service from outside k8s cluster
ingress:
  enabled: false
  Host:

clients:
#  - id: "merger"
#    secret: "1234"
# To be fully open (No authentication):
#  - id: "*"
#  - secret: "*"

# Cert-manger cluster issuer
clusterIssuer:
# If not provided and ssl:true, then a certificate must be provided externally as a secret. Here is a sample layout:
#
#      apiVersion: v1
#      kind: Secret
#      metadata:
#        name: {{ include "sk-crd.fullname" . }}-cert
#        namespace: skas-system
#      type: kubernetes.io/tls
#      data:
#        ca.crt: LS0tLS.......
#        tls.crt: LS0tLS.....
#        tls.key: LS0t......
#
# Refer to the documentation for more information about certificate creation

# --------------------------------- LDAP configuration
ldap:
  # The host and port of the LDAP server.
  # If port isn't supplied, it will be guessed based on the TLS configuration. 389 or 636.
  host:
  port:

  # Timeout on connection to ldap server. Default to 10
  timeoutSec: 10

  # Required if LDAP host does not use TLS.
  insecureNoSSL: false

  # Don't verify the CA.
  insecureSkipVerify: false

  # Connect to the insecure port then issue a StartTLS command to negotiate a
  # secure connection. If unsupplied secure connections will use the LDAPS protocol.
  startTLS: false

  # Path to a trusted root certificate file, or Base64 encoded PEM data containing root CAs.
  rootCA:
  rootCAData:

  # If server require client authentication with certificate.
  #  Path to a client cert file and a private key file
  clientCert:
  clientKey:

  # BindDN and BindPW for an application service account. The connector uses these
  # credentials to search for users and groups.
  bindDN:
  bindPW:

  userSearch:
    # BaseDN to start the search from. For example "cn=users,dc=example,dc=com"
    baseDN:
    # Optional filter to apply when searching the directory. For example "(objectClass=person)"
    filter:
    # Attribute to match against the login. This will be translated and combined
    # with the other filter as "(<loginAttr>=<login>)".
    loginAttr:
    #  Can either be:
    # * "sub" - search the whole sub tree (Default)
    # * "one" - only search one level
    scope: "sub"
    # The attribute providing the numerical user ID
    numericalIdAttr:
    # The attribute providing the user's email
    emailAttr:
    # The attribute providing the user's common name
    cnAttr:

  groupSearch:
    # BaseDN to start the search from. For example "cn=groups,dc=example,dc=com"
    baseDN:
    # Optional filter to apply when searching the directory. For example "(objectClass=posixGroup)"
    filter: (objectClass=posixgroup)
    # Defaults to "sub"
    scope: "sub"
    # The attribute of the group that represents its name.
    nameAttr: cn
    # The filter for group/user relationship will be: (<linkGroupAttr>=<Value of LinkUserAttr for the user>)
    # If there is several value for LinkUserAttr, we will loop on.
    linkGroupAttr:
    linkUserAttr:

